#!/usr/bin/env pwsh

param (
    [string]$InputFile,
    [string]$OutputFile
)

# Funktion zum KÃ¼rzen des Loggernamens
function Shorten-LoggerName($loggerName) {
    $parts = $loggerName -split '\.'
    $shortened = ($parts[0..($parts.Length - 2)] | ForEach-Object { $_.Substring(0, 1) }) -join '.'
    return "$shortened.$($parts[-1])"
}

# Funktion zum Verarbeiten einer Zeile
function Process-Line($line) {
    try {
        $json = $line | ConvertFrom-Json
        $loggerName = if ($json.loggerName) { Shorten-LoggerName $json.loggerName } else { $null }
        $level = $json.level
        $message = $json.message
        if ($message) { return "[${level} | ${loggerName}] $message" }
    } catch {
        Write-Host "Fehler beim Parsen der Zeile: $line" -ForegroundColor Yellow
    }
    return $null
}

# Eingabequelle bestimmen
$reader = if ($InputFile) {
    if (-not (Test-Path $InputFile)) {
        Write-Error "Die Eingabedatei '$InputFile' wurde nicht gefunden."
        exit 1
    }
    [System.IO.StreamReader]::new($InputFile)
} else {
    [Console]::In
}

# Ergebnisse speichern
$results = @()
try {
    while (($line = $reader.ReadLine()) -ne $null) {
        $processedLine = Process-Line $line
        if ($processedLine) { $results += $processedLine }
    }
} finally {
    if ($InputFile) { $reader.Close() }
}

# Ergebnisse ausgeben oder in eine Datei schreiben
if ($OutputFile) {
    $results | Out-File -FilePath $OutputFile -Encoding UTF8
} else {
    $results | ForEach-Object { Write-Output $_ }
}
