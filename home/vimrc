" .vimrc
" Author:  Sebastian <seek> Kusnier, seek /at/ matrixcode /dot/ de
" Source:  https://github.com/kusnier/dotfiles/blob/master/home/vimrc
" License: This file is placed in the public domain.
"
" USE :options
"  for a linteractive list of all options

" Speedup: http://stackoverflow.com/questions/4984335/vim-dynamic-runtimepath-per-module-vim-and-slow-startup
" Profiling: http://stackoverflow.com/questions/1687799/profiling-vim-startup-time

" Preamble ---------------------------------------------------------------- {{{

" Load a merged version of all bundles (Move this folder to a ramdisk)
runtime bundle/vim-pathogen/autoload/pathogen.vim
if isdirectory(expand("/dev/shm/vim.bundle.merged"))
  call pathogen#infect("/dev/shm/vim.bundle.merged")
elseif isdirectory(expand("~/.vim/bundle.merged"))
  call pathogen#infect("~/.vim/bundle.merged")
else
  call pathogen#infect()
endif

set nocompatible
filetype plugin indent on

" -----------------------------------------------------------
" HowTo: Pathogen and vimball
" -----------------------------------------------------------
" :e name.vba
" :!mkdir ~/.vim/bundle/name
" :UseVimball ~/.vim/bundle/name

" }}}
" Printer setup ----------------------------------------------------------- {{{

set printoptions=paper:A4,syntax:a,duplex:off

" }}}
" Basic options ----------------------------------------------------------- {{{

set encoding=utf8
set noswapfile
let mapleader = ","
let maplocalleader = "\\"

" Mouse setup
set mousemodel=extend
" Enable mouse usage (all modes) in terminals
set mouse=a
" focus follows mouse
" set mousefocus

" No bell or flash wanted
set noerrorbells
set novisualbell
set t_vb=

" Trailing whitespace will be highlighted automatically
match ErrorMsg '\s\+$'

" make sure that max lines are displayed (80 and 120 are from ZF Coding standards)
if v:version > 702
  set colorcolumn=+1,121
endif

" Hide buffers when they are abandoned
"set hidden "makes problems with VCSVimdiff, Closing diff is not working right
set nojoinspaces
" enable backspace to delete anyting (includes \n) in insert mode
set backspace=indent,eol,start
set whichwrap+=<,>,h,l
set display=lastline " display as much as possible from the last line
set number
set cursorline
set ttyfast
set scrolloff=3     "start scrolling 3 lines before edge of viewport
set sidescroll=1
set sidescrolloff=3 " same, but for columns

" Virtual editing means that the cursor can be positioned where there is no
" characer.
set virtualedit+=block

" remap j an k to jump to the rows in the smae line, if lines wraps
nnoremap j gj
nnoremap k gk

" Fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

set autoread " automatically detect changes and re-read the file

" jump to the last position when reopening a file
augroup line_return
    au!
    au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" Paste toggle (,p)
set pastetoggle=<leader>\\p
map <leader>p :set invpaste paste?<CR>

" Save when losing focus
au FocusLost * :silent! wall

" }}}
" General Bindings -------------------------------------------------------- {{{

" Use space for something useful
nnoremap <Space> :
nnoremap <Space><Space> :!
inoremap <C-Space> <C-X><C-]>

" Get efficient: shortcut mappings
nnoremap ; :

" Source
vnoremap <leader>S y:execute @@<cr>
nnoremap <leader>S ^vg_y:execute @@<cr>

" List previous opened files
nnoremap <leader>o :oldfiles<cr>

" }}}
" Leader mappings --------------------------------------------------------- {{{

" strip all trailing whitespace in the current file
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

" Tabs
set switchbuf=usetab
nmap <leader>tn <Esc>:tabnew<CR>
" map <leader>tn :tabnew %<cr>
" map <leader>te :tabedit
" map <leader>tc :tabclose<cr>
" map <leader>tm :tabmove 
nnoremap <leader>x <c-^>

" }}}
" Store temporary vim files in a central spot ----------------------------- {{{

set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*" 
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backup

if v:version > 702
  set undofile
  set undodir=~/.vim-undo
endif

" }}}
" Text-Formatting, Identing, Tabbing, Align ------------------------------- {{{

set textwidth=120
set linebreak
set wrap

" use full featured format-options. see "help fo-table for help
set formatoptions=
set formatoptions+=c " Format comments
set formatoptions+=r " Continue comments by default
set formatoptions+=o " Make comment when using o or O from comment line
set formatoptions+=q " Format comments with gq
set formatoptions+=n " Recognize numbered lists
set formatoptions+=2 " Use indent from 2nd line of a paragraph
set formatoptions+=l " Don't break lines that are already long
set formatoptions+=1 " Break before 1-letter words

" re-hardwrap paragraphs of text
nnoremap <leader>q gqip

set autoindent
set copyindent
set smartindent

" Tab options
set tabstop=2 " number of spaces the tab stands for
set expandtab
set shiftwidth=2 " number of spaces used for (auto)indenting
set softtabstop=2 " if non-zero, number of spaces to insert for a <tab>

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc><right>

nnoremap <leader>Al :left<cr>
nnoremap <leader>Ac :center<cr>
nnoremap <leader>Ar :right<cr>
vnoremap <leader>Al :left<cr>
vnoremap <leader>Ac :center<cr>
vnoremap <leader>Ar :right<cr>

" Quickreturn
inoremap <c-cr> <esc>A<cr>
inoremap <s-cr> <esc>A:<cr>

" Change case
nnoremap U gUiw

" }}}
" List chars - Show invisibles -------------------------------------------- {{{

set list listchars=tab:»·,trail:·,eol:¬,extends:❯,precedes:❮
set showbreak=↪
set fillchars=diff:⣿,vert:│

if !exists("g:colors_name")
  highlight NonText guifg=#2a2a2a
  highlight SpecialKey guifg=#ff2a2a
endif

" }}}
" Folding ----------------------------------------------------------------- {{{

set foldlevelstart=0

" Space to toggle folds.
nnoremap <s-Space> za
vnoremap <s-Space> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

" Make the current location sane.
nnoremap <c-cr> zvzz

" Use ,z to "focus" the current fold.
nnoremap <leader>z zMzvzz

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()


" }}}
" Tabs -------------------------------------------------------------------- {{{

set showtabline=2 " Always show tab bar

" }}}
" Window handling --------------------------------------------------------- {{{

" minimal number of lines used for the current window
set wh=1
" minimal number of lines used for any window
set wmh=0
" make all windows the same size when adding/removing windows
set equalalways
set splitbelow " New window goes below
set splitright " New windows goes right

" Split resizing
nmap <left>  :3wincmd <<cr>
nmap <right> :3wincmd ><cr>
nmap <up>    :3wincmd +<cr>
nmap <down>  :3wincmd -<cr>


function! WinMove(key) 
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr()) "we havent moved
    if (match(a:key,'[jk]')) "were we going up/down
      wincmd v
    else 
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction
" Split/Move to window with the same command
nnoremap <silent> <c-h> :call WinMove('h')<cr>
nnoremap <silent> <c-k> :call WinMove('k')<cr>
nnoremap <silent> <c-l> :call WinMove('l')<cr>
nnoremap <silent> <c-j> :call WinMove('j')<cr>
map <leader>wc :wincmd q<cr>
map <leader>wr <C-W>r
map <leader>H  :wincmd H<cr>
map <leader>K  :wincmd K<cr>
map <leader>L  :wincmd L<cr>
map <leader>J  :wincmd J<cr>


" redraw window so search terms are centered
nnoremap n nzzzv
nnoremap N Nzzzv

" Resize splits when the window is resized
au VimResized * wincmd =

" }}}
" Buffer ------------------------------------------------------------------ {{

map <Leader>ls :buffers<CR>
" cycle thru buffers ...
nnoremap <Leader>d :bnext<cr>
nnoremap <Leader>f :bprev<cr>
" Buffer navigation (,,) (,]) (,[) (,ls)
map <Leader>, <C-^>
"nmap <tab> :bn<cr>
"nmap <s-tab> :bp<cr>

" }}}
" Diff -------------------------------------------------------------------- {{{

"Ignore changes in amount of white space.
set diffopt=filler " Add vertical spaces to keep right and left aligned
set diffopt+=iwhite

" Diffoff
nnoremap <leader>D :diffoff!<cr>

" }}}
" Searching, Substituting ------------------------------------------------- {{{

" select case-insenitiv search
set ignorecase
" No ignorecase if Uppercase chars in search
set smartcase
" change the way backslashes are used in search patterns
set magic
" begin search at top when EOF reached
set wrapscan
" jump to matches during entering the pattern
set showmatch
set matchtime=3
set matchpairs+=<:> " these tokens belong together

" highlight all matches..., remove hl on esc
set hlsearch
nnoremap <silent> <esc> :nohlsearch<return><esc>
" ...and also during entering the pattern
set incsearch

" use 'g'-flag when substituting (subst. all matches in that line, not only first)
" to turn off, use g (why is there no -g ?)
set gdefault
" turn off the fucking :s///gc toggling
set noedcompatible
"search+replace word under cursor
nnoremap <C-S> :,$s/\<<C-R><C-W>\>/

" Open a Quickfix window for the last search.
nnoremap <silent> <leader><leader>/ :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Ack for the last search.
nnoremap <silent> <leader><leader>? :execute "Ack! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>

" Use tab jump between matches
map <tab> %

" }}}
" Spelling ---------------------------------------------------------------- {{{

map <leader>spd :setlocal spelllang+=de<CR>
map <leader>spe :setlocal spelllang+=en<CR>
map <leader>spp :setlocal spelllang+=pl<CR>

" }}}
" Completion -------------------------------------------------------------- {{{

set omnifunc=syntaxcomplete#Complete " Set omni-completion method.
" -----------------------------------------------------------
" Insert-Mode Completion
" -----------------------------------------------------------
"  . scan the current buffer ('wrapscan' is ignored)
"  w scan buffers from other windows
"  b scan other loaded buffers that are in the buffer list
"  u scan the unloaded buffers that are in the buffer list
"  t tag completion
"  i scan current and included files
"  k scan the files given with the 'dictionary' option
set complete=.,w,b,u,t,i,k

"  longest  Only insert the longest common text of the matches.  If
"     the menu is displayed you can use CTRL-L to add more
"     characters.  Whether case is ignored depends on the kind
"     of completion.  For buffer text the 'ignorecase' option is
"     used.
"
"  menuone  Use the popup menu also when there is only one match.
"     Useful when there is additional information about the
"     match, e.g., what file it comes from.
"
"  preview  Show extra information about the currently selected
"     completion in the preview window.  Only works in
"     combination with "menu" or "menuone".
"
set completeopt=longest,menuone,preview
" completefunc
"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"inoremap <expr> <C-p> pumvisible() ? '<C-n>' : '<C-n><C-r>=pumvisible() ? "\<lt>up>" : ""<CR>'
"inoremap <expr> <C-n> pumvisible() ? '<C-n>' : '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

set infercase " adjust the case of auto completed words


" }}}
" Tags / Ctags ------------------------------------------------------------ {{{

set showfulltag
set tags=
set tags+=tags;$HOME
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
map <leader>] :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" }}}
" Highlighting, colors, fonts --------------------------------------------- {{{

if has("gui_running")
  set t_Co=256
else
  set t_Co=16
endif

set background=dark

" when we have a colored terminal or gui...
if &t_Co > 2 || has("gui_running")
    " ...then use highlighting
    syntax on
endif

if has("gui_running")
  "Standartgroesse bei'm GUI-Fenster
  "win 120 40
  "columns    width of the display
  ""set co=120
  "lines      number of lines in the display
  ""set lines=41
  if has("win32")
    set guifont=Bitstream_Vera_Sans_Mono:h8:cANSI
  elseif has("gui_macvim")
    set guifont=DejaVu\ Sans\ Mono:h12
    set transparency=2
  else
    "set guifont=Monospace\ 8
    set guifont=DejaVu\ Sans\ Mono\ 8
  endif

colorscheme molokai

endif
" Custom highlights
if !exists("g:colors_name")
  highlight Visual term=reverse cterm=reverse guibg=#051060
  highlight Normal      guifg=gray      guibg=black
  highlight Special     guifg=Red
  highlight Folded      guifg=DarkRed   guibg=LightGrey
  highlight FoldColumn  guifg=DarkGreen
  highlight CursorLine guibg=Grey15
  highlight LineNr guibg=#000040 ctermbg=4
  highlight Folded guibg=Grey55
  highlight ModeMsg guibg=#8b0036
  highlight Pmenu guibg=#000050 ctermbg=12
  highlight PmenuSel guibg=#000099 guifg=yellow
endif
if exists("g:colors_name") && g:colors_name == 'molokai'
  " Autochange color in insert mode
  highlight StatusLine guifg=#2b0036 guibg=white
  highlight Search guibg=#f0e600 guifg=black
  autocmd InsertEnter * highlight StatusLine guifg=#8b0036
  autocmd InsertLeave * highlight StatusLine guifg=#2b0036
else
  " Autochange color in insert mode
  highlight StatusLine guifg=#ae81ff guibg=white
  autocmd InsertEnter * highlight StatusLine guifg=#f92672
  autocmd InsertLeave * highlight StatusLine guifg=#ae81ff
endif

" Override all colorscheme
highlight ColorColumn guibg=#2d2d2d
highlight DiffText guibg=#660000
highlight Comment gui=italic


" how many lines to sync backwards
syn sync minlines=10000 maxlines=10000
" how many lines to search backward after a jump to check syntax
let c_minlines = 200
" aldo highlight some things in comments
let c_comment_strings = 1

" use css when converting syntax to html (2html.vim)
let html_use_css = 1

" }}}
" Statusline, Menu, Command ----------------------------------------------- {{{

" use tab for auto-expansion in menus
set wildchar=<TAB>
" show a list of all matches when tabbing a command
set wildmenu
" how command line completion works
""set wildmode=list,full
set wildmode=list:longest,list:full
" ignore some files for filename completion
set wildignore=*.o,*.r,*.so,*.sl,*.tar,*.tgz,*.svn
set wildignore+=*.DS_Store                       " OSX bullshit
set wildignore+=*/target/app/*
set wildignore+=*/target/classes/*
set wildignore+=*/target/*_RELEASE/*
" remember last 2000 typed commands
set history=200
if has('cmdline_info')
  " show cursor position below each window
  set ruler
  " a ruler on steroids
  set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) 
  " Show (partial) command in status line.
  set showcmd
endif
" shows the current status (insert, visual, ...) in statusline
set showmode
" use shortest messages
set shortmess=atI
if has('statusline')
  " show always statusline of last window
  set laststatus=2
" statusline
" cf the default statusline: %<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
" format markers:
"   %< truncation point
"   %n buffer number
"   %f relative path to file
"   %m modified flag [+] (modified), [-] (unmodifiable) or nothing
"   %r readonly flag [RO]
"   %y filetype [ruby]
"   %w Preview window flag, text is "[Preview]"
"   %= split point for left and right justification
"   %-35. width specification
"   %l current line number
"   %L number of lines in buffer
"   %c current column number
"   %V current virtual column number (-n), if different from %c
"   %P percentage through buffer
"   %) end of width specification
let &statusline='%< %n:%f %m%r%y%w%{fugitive#statusline()}%=%-35.(line: %l of %L, col: %c%V (%P)%)'
" cfi#format has problem with eclim
" let &statusline='%< %n:%f %m%r%y%w%{cfi#format("[%s()]", "")}%=%-35.(line: %l of %L, col: %c%V (%P)%)'
endif

" Command mode mappings
" jump to start of command line
cnoremap <C-a> <Home>
" jump to end of command line
cnoremap <C-e> <End>

" }}}
" Spell ------------------------------------------------------------------- {{{

set nospell
set spelllang=de,en
if filereadable("~/.vim/spell/spf.add")
 set spellfile=~/.vim/spell/spf.add
endif
if filereadable("~/.vim/spell/de.latin1.spl")
 set spellfile=~/.vim/spell/de.latin1.spl
endif

set dictionary+=/usr/share/dict/words
set dictionary+=~/.vim/dict/american-english
set dictionary+=~/.vim/dict/ngerman
"set dictionary+=~/.vim/dict/polish

map <F7> :set spell!<CR>

" }}}
" Plugin options ---------------------------------------------------------- {{{

" Clam {{{

nnoremap ! :Clam<space>
vnoremap ! :ClamVisual<space>

" }}}
" CamelCaseComplete {{{

let g:CamelCaseComplete_complete = '.,w'
let g:CamelCaseComplete_FindStartMark = ''

" }}}
" SuperTab {{{

let g:SuperTabDefaultCompletionType='context'
let g:SuperTabContextDefaultCompletionType = "<c-n>"
let g:SuperTabRetainCompletionDuration='session'
"let g:SuperTabLongestEnhanced=1
let g:SuperTabLongestHighlight=1
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']

autocmd FileType *
  \ if &omnifunc != '' |
  \   call SuperTabChain(&omnifunc, "context") |
  \   call SuperTabSetDefaultCompletionType("context") |
  \ endif

" }}}
" ZenCoding {{{

" http://code.google.com/p/zen-coding/
" Plugin is installed. Learn it Bitch!!! :)
let g:user_zen_leader_key = '<c-;>'
let g:user_zen_settings = {
\  'indentation' : '  ',
\  'perl' : {
\    'aliases' : {
\      'req' : 'require '
\    },
\    'snippets' : {
\      'use' : "use strict\nuse warnings\n\n",
\      'warn' : "warn \"|\";",
\    }
\  }
\}

" }}}
" Powerline {{{

if has("gui_running")
  let g:Powerline_symbols = 'fancy'
endif

" }}}
" Cope {{{

map <leader>qc :botright cope<cr>
map <leader>qn :cn<cr>
map <leader>qp :cp<cr>

" }}}
" Easytags {{{

" the easytags plug-in will write to the first existing tags file seen by
" In other words: If a project specific tags file is found it will be used,
" otherwise the plug-in falls back to the global tags file (or a file type specific tags file).
let g:easytags_always_enabled = 0
let g:easytags_dynamic_files = 2
let g:easytags_resolve_links = 1
let g:easytags_include_members = 1
let g:easytags_auto_highlight = 0
let g:easytags_on_cursorhold = 0
let g:easytags_auto_update = 0

highlight cMember guifg=#1155ff
highlight phpFunctionsTag guifg=#1155ff
highlight phpClassesTag guifg=#ff0077

" }}}
" CtrlP {{{

let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
let g:ctrlp_extensions = ['tag', 'qfx', 'dir', 'buffertag', 'mixed']
let g:ctrlp_working_path_mode = 2
let g:ctrlp_root_markers = ['VERSION', 'xpinstall/', 'ivy.xml']
let g:ctrlp_mru_files = 1
let g:ctrlp_dont_split = 'NERD_tree_2'

nnoremap <Leader>bs :CtrlPBuffer<CR>
nnoremap <Leader>pb :CtrlPBuffer<CR>
nnoremap <leader>pr :CtrlPMRUFiles<cr>
nnoremap <leader>pp :CtrlPMixed<cr>
nnoremap <leader>pt :CtrlPTag<cr>
nnoremap <leader>pc :CtrlP %:h<cr>

" }}}
" TabMan {{{

let g:tabman_toggle = '<leader>tm'
let g:tabman_focus  = '<leader>ftm'
let g:tabman_side   = 'right'
let g:tabman_width = 20

" }}}
" MarkGreen {{{

map <silent> <Leader>ut :call MakeGreen()<cr>

" }}}
" Tabbar {{{

nnoremap <leader>tb :TagbarToggle<CR>
nnoremap <leader>tl :TagbarToggle<CR>

" }}}
" Rainbow Parentheses {{{

nnoremap <leader>rp :RainbowParenthesesToggle<CR>

" }}}
" Fugitive {{{

nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gr :Gremove<CR>
nnoremap <Leader>gl :Glog<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gm :Gmove
nnoremap <Leader>gp :Ggrep
nnoremap <Leader>gR :Gread<CR>
nnoremap <Leader>gg :Git
nnoremap <Leader>gd :Gdiff<CR>

" }}}
" UltiSnips {{{

let g:UltiSnipsEditSplit = "vertical"

" }}}
" vim-pasta {{{

let g:pasta_enabled_filetypes = ['php', 'ruby', 'javascript', 'css', 'sh']

" }}}
" Gundo {{{

nnoremap <leader>gt :GundoToggle<CR>

" }}}
" EasyMotion {{{

let g:EasyMotion_leader_key='\'

" }}}
" Ack {{{

let g:ackprg="ack -H --nocolor --nogroup --column"
nnoremap <leader>a :Ack!<space>

" }}}
" notes.vim {{{

let g:notes_directory = '~/.vim-notes'

" }}}
" Indent Guides {{{

autocmd FileType php         IndentGuidesEnable
autocmd FileType html        IndentGuidesEnable
autocmd FileType javascript  IndentGuidesEnable
autocmd FileType *           IndentGuidesDisable

" }}}
" NERDCommenter {{{

let g:NERDCreateDefaultMappings = 0
nmap <leader>ccc <plug>NERDCommenterComment
nmap <leader>cc<space> <plug>NERDCommenterToggle
nmap <leader>ccm <plug>NERDCommenterMinimal
nmap <leader>ccs <plug>NERDCommenterSexy
nmap <leader>cci <plug>NERDCommenterInvert
nmap <leader>ccy <plug>NERDCommenterYank
nmap <leader>ccl <plug>NERDCommenterAlignLeft
nmap <leader>ccb <plug>NERDCommenterAlignBoth
nmap <leader>ccn <plug>NERDCommenterNest
nmap <leader>ccu <plug>NERDCommenterUncomment
nmap <leader>cc$ <plug>NERDCommenterToEOL
nmap <leader>ccA <plug>NERDCommenterAppend

" }}}
" NERDTree {{{

nmap  <leader>nt :NERDTreeToggle<cr>
nmap  <leader>nmt :NERDTreeMirror<cr>
nmap  <leader>nft :NERDTreeFind<cr>

au Filetype nerdtree setlocal nolist
let NERDTreeChDirMode=2 "CWD is changed whenever the tree root is changed
let NERDTreeDirArrows=1
let NERDTreeMinimalUI=1

" }}}
" ftPlugin: xml {{{

" update xml.vim: if (&filetype == 'xslt' || &filetype == 'html' || &filetype == 'xhtml') && (!exists ("g:xml_no_html"))
let xml_tag_syntax_prefixes = 'html\|xml\|xsl\|docbk'
let xml_use_xhtml = 1
"autocmd FileType html let xml_jump_string = "`"
"autocmd FileType xml let xml_jump_string = "`"

if !exists("*XmlAttribCallback")
function XmlAttribCallback( xml_tag )
    if a:xml_tag ==? "table"
        return "cellpadding=\"0\" cellspacing=\"0\" border=\"0\""
    elseif a:xml_tag ==? "link"
        return "href=\"/site.css\" rel=\"StyleSheet\" type=\"text/css\""
    elseif a:xml_tag ==? "body"
        return "bgcolor=\"white\""
    elseif a:xml_tag ==? "frame"
        return "name=\"NAME\" src=\"/\" scrolling=\"auto\" noresize"
    elseif a:xml_tag ==? "frameset"
        return "rows=\"0,*\" cols=\"*,0\" border=\"0\""
    elseif a:xml_tag ==? "img"
        return "src=\"\" width=\"0\" height=\"0\" border=\"0\" alt=\"\""
    elseif a:xml_tag ==? "a"
        if has("browse")
            " Look up a file to fill the href. Used in local relative file
            " links. typeing your own href before closing the tag with `>'
            " will override this.
            let cwd = getcwd()
            let cwd = substitute (cwd, "\\", "/", "g")
            let href = browse (0, "Link to href...", getcwd(), "")
            let href = substitute (href, cwd . "/", "", "")
            let href = substitute (href, " ", "%20", "g")
        else
            let href = ""
        endif
        return "href=\"" . href . "\""
    else
        return 0
    endif
endfunction
endif

" }}}
" dbext {{{

let g:dbext_default_buffer_lines = 10
" each buffer uses its OWN Result buffer
let g:dbext_default_use_sep_result_buffer = 1
let g:dbext_default_DBI_split_on_pattern = ';'
let g:dbext_default_dict_show_owner = 0
:let  g:dbext_default_DBI_max_rows = 1000
"let  g:dbext_default_DBI_column_delimiter = "|"
" will be called automatically each time the Result buffer is updated
function! DBextPostResult(db_type, buf_nr)
  " If dealing with a MYSQL database
  "if a:db_type == 'MYSQL'
      " Assuming the first column is an integer
      " highlight it using the WarningMsg color
      "syn match logWarn '^\d\+'
      "hi def link logWarn		WarningMsg
      setlocal ft=dbi_result
      setlocal nolist
  "endif
  set dictionary-=/usr/share/dict/words
endfunction
":au BufNewFile,BufRead Result setf dbi_result
":au BufNewFile,BufRead Result set nolist

" Load dbext connection profiles, this part is secret
if filereadable(expand("~/.vimrc.sql_profiles"))
  so ~/.vimrc.sql_profiles
endif

" }}}
" VCSCommand {{{

let VCSCommandSVKExec = 'no_svk'
let VCSCommandDeleteOnHide = 'yes'
" VCSCommandEnableBufferSetup is not working
let VCSCommandEnableBufferSetup = 'yes'

" }}}
" Syntastic {{{

let g:syntastic_enable_signs=1
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1

" }}}
" sql - random plugins {{{

let g:sql_type_default = 'mysql'
let g:omni_sql_include_owner = 0
nmap <silent> <S-F12> :new ~/.vimrc.dbi_vars<CR>

" }}}
" HTML5 {{{

let g:event_handler_attributes_complete = 0
let g:rdfa_attributes_complete = 0
let g:microdata_attributes_complete = 0
let g:atia_attributes_complete = 0

" }}}

" }}}

" Mini-plugins ------------------------------------------------------------ {{{
" Source: http://bitbucket.org/sjl/dotfiles/src/tip/vim/

" Ack motions {{{

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

nnoremap <silent> \a :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> \a :<C-U>call <SID>AckMotion(visualmode())<CR>

function! s:CopyMotionForType(type)
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction

function! s:AckMotion(type) abort
    let reg_save = @@

    call s:CopyMotionForType(a:type)

    execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

    let @@ = reg_save
endfunction

" }}}


" }}}

" Various filetype-specific stuff ----------------------------------------- {{{

" C {{{

augroup ft_c
    au!
    au FileType c setlocal foldmethod=syntax
augroup END

" }}}

" text {{{

augroup ft_text
  au!
  autocmd FileType text setlocal textwidth=78
augroup END

" }}}

" greasemonkey {{{

augroup ft_greasemonkey
  au!
  au BufRead,BufNewFile */gm_scripts/*.js set ft=javascript.greasemonkey
augroup END

" }}}

" zsh {{{

augroup ft_zsh
  au!
  au BufRead,BufNewFile *.zsh-theme set ft=zsh
augroup END

" }}}

" Vim {{{

augroup ft_vim
    au!
    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType vim setlocal foldlevelstart=0
    autocmd FileType vim setlocal foldenable
    autocmd FileType help setlocal textwidth=78
    "autocmd BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" }}}

" twiki {{{

augroup ft_twiki
  au!
  au BufNewFile,BufRead /tmp/vimperator-* setf twiki
  au BufNewFile,BufRead /tmp/vimperator-* set spell
augroup END

" }}}

" svn {{{

augroup ft_svn
  au!
  autocmd FileType svn setlocal spell
  autocmd FileType svn setlocal spelllang=en
augroup END

" }}}

" vcscommit {{{

augroup ft_vcscommit
  au!
  autocmd FileType vcscommit setlocal spell
  autocmd FileType vcscommit setlocal spelllang=en
  autocmd FileType vcscommit setlocal textwidth=78
augroup END

" }}}

" sql {{{

augroup ft_sql
  au!
  autocmd FileType sql setlocal spell
  autocmd BufNewFile,BufRead sqsh-edit* setf sql
  autocmd BufNewFile,BufRead /tmp/sql* setf sql
  autocmd BufNewFile,BufRead *.ddl setf sql
  autocmd FileType sql let b:CamelCaseComplete_complete = '.,w,k'
augroup END

" }}}

" sh {{{

augroup ft_sh
  au!
  autocmd BufNewFile,BufRead /tmp/bash-fc* setf sh
augroup END

" }}}

" apache {{{

augroup ft_apache
  au!
  autocmd BufNewFile,BufRead *.conf.tmpl set ft=apache
  autocmd BufNewFile,BufRead */sites-available/*.conf set ft=apache
  autocmd BufNewFile,BufRead */sites-enabled/*.conf set ft=apache
  autocmd BufNewFile,BufRead */sites-enabled/00* set ft=apache
  autocmd BufNewFile,BufRead */sites-available/00* set ft=apache
  autocmd BufNewFile,BufRead */config/*/apache/* set ft=apache
  autocmd BufNewFile,BufRead */config/*/apache2/* set ft=apache
augroup END

" }}}

" nagios {{{

augroup ft_nagios
  au!
  autocmd BufNewFile,BufRead /*etc/nagios/*.cfg,*/nagios/trunk/*.cfg,*sample-config/template-object/*.cfg{,.in},/var/lib/nagios/objects.cache set ft=nagios
augroup END

" }}}

" crontab {{{

augroup ft_crontab
  au!
  autocmd BufNewFile,BufRead */config/*/cron/*.tab set ft=crontab
augroup END

" }}}

" gitcommit {{{

augroup ft_gitcommit
  au!
  autocmd FileType gitcommit setlocal spell spelllang=en
  autocmd FileType gitcommit setlocal textwidth=78
augroup END

" }}}

" markdown {{{

augroup ft_markdown
  au!
  autocmd FileType markdown setlocal spell spelllang=en complete+=k
augroup END

" }}}

" changelog {{{

augroup ft_changelog
  au!
  autocmd FileType changelog setlocal spell spelllang=en complete+=k
augroup END

" }}}

" php {{{

augroup ft_php
  au!
  " Folding classes and functions
  autocmd FileType php let php_folding=1
  autocmd FileType php setlocal foldmethod=syntax
  " For highlighting baselib functions
  autocmd FileType php let php_baselib = 1
  " Disable short tags
  autocmd FileType php let php_noShortTags = 1
  autocmd FileType php let php_parentError = 1

  " set "make" command when editing php files
  autocmd FileType php setl makeprg=php\ -l\ %
  autocmd FileType php setl errorformat=%m\ in\ %f\ on\ line\ %l
  autocmd FileType php setlocal omnifunc=phpcomplete#CompletePHP
  autocmd FileType php let b:CamelCaseComplete_complete = '.,w,t'
augroup END

" }}}

" python {{{

augroup ft_python
  au!
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType python setlocal define=^\s*\\(def\\\\|class\\)
augroup END

" }}}

" Ruby {{{

augroup ft_ruby
    au!
    au Filetype ruby setlocal foldmethod=syntax
augroup END

" }}}

" javascript {{{

augroup ft_javascript
  au!
  autocmd FileType javascript setlocal foldmethod=marker
  autocmd FileType javascript setlocal foldmarker={,}
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS

" Nodeunit
  autocmd BufNewFile,BufRead test/test-*.js :compiler nodeunit

  " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
  " positioned inside of them AND the following code doesn't get unfolded.
  autocmd Filetype javascript inoremap <buffer> {<cr> {}<left><cr><space><space><space><space>.<cr><esc>kA<bs>
augroup END

" }}}

" vimperatorrc {{{

augroup ft_vimperator
    au!
    au BufNewFile,BufRead .vimperatorrc set filetype=vimperator
    au BufNewFile,BufRead ~/Library/Caches/TemporaryItems/vimperator-*.tmp set nolist wrap linebreak columns=100 colorcolumn=0
augroup END

" }}}
"
" Java {{{

augroup ft_java
    au!
    autocmd FileType java setlocal foldmethod=marker
    autocmd FileType java setlocal foldmarker={,}
augroup END

" }}}

" Ruby {{{

augroup ft_ruby
    au!
    au Filetype ruby setlocal foldmethod=syntax
augroup END

" }}}

" Vagrant {{{

augroup ft_vagrant
    au!
    au BufRead,BufNewFile Vagrantfile set ft=ruby
augroup END

" }}}

" html {{{

augroup ft_html
  au!
  autocmd FileType html,xsl let b:loaded_delimitMate = 0
  autocmd FileType html,xsl setlocal foldmethod=manual
  autocmd FileType html,xsl setlocal omnifunc=htmlcomplete#CompleteTags

  " Use <localleader>tf to fold the current tag.
  au FileType html,xsl nnoremap <buffer> <localleader>tf Vatzf

  " Use Shift-Return to turn this:
  "     <tag>|</tag>
  "
  " into this:
  "     <tag>
  "         |
  "     </tag>
  au FileType html,xsl nnoremap <buffer> <s-cr> vit<esc>a<cr><esc>vito<esc>i<cr><esc>

  " Indent tag
  au FileType html,xsl nnoremap <buffer> <localleader>= Vat=
augroup END

" }}}

" css {{{

augroup ft_css
  au!
  autocmd BufNewFile,BufRead *.less setlocal filetype=less

  autocmd Filetype less,css setlocal foldmethod=marker
  autocmd Filetype less,css setlocal foldmarker={,}
  autocmd Filetype less,css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd Filetype less,css setlocal iskeyword+=-

  function! CssFoldText()
      let line = getline(v:foldstart)
      let nnum = nextnonblank(v:foldstart + 1)
      while nnum < v:foldend+1
          let line = line . " " . substitute(getline(nnum), "^ *", "", "g")
          let nnum = nnum + 1
      endwhile
      return line
  endfunction

  autocmd Filetype css setlocal foldtext=CssFoldText()
  autocmd Filetype css setlocal fillchars=fold:\ 

  " Use <leader>S to sort properties.  Turns this:
  "
  "     p {
  "         width: 200px;
  "         height: 100px;
  "         background: red;
  "
  "         ...
  "     }
  "
  " into this:

  "     p {
  "         background: red;
  "         height: 100px;
  "         width: 200px;
  "
  "         ...
  "     }
  au BufNewFile,BufRead *.less,*.css nnoremap <buffer> <localleader>S ?{<CR>jV/\v^\s*\}?$<CR>k:sort<CR>:noh<CR>

  " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
  " positioned inside of them AND the following code doesn't get unfolded.
  au BufNewFile,BufRead *.less,*.css inoremap <buffer> {<cr> {}<left><cr><space><space><space><space>.<cr><esc>kA<bs>
augroup END

" }}}


" xml {{{

augroup ft_xml
  au!
  autocmd FileType xml let b:loaded_delimitMate = 0
  autocmd FileType xml setlocal foldmethod=manual

  " Use <localleader>tf to fold the current tag.
  au FileType xml nnoremap <buffer> <localleader>tf Vatzf

  " Indent tag
  au FileType xml nnoremap <buffer> <localleader>= Vat=

  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Formatting XML in Vim with indent command
  autocmd FileType xml setlocal equalprg=xmllint\ --format\ --recover\ -\ 2>/dev/null
augroup END

" }}}

" c {{{

augroup ft_c
  au!
  autocmd FileType c setlocal foldmethod=syntax
  autocmd FileType c setlocal omnifunc=ccomplete#Complete
augroup END

" }}}

" xpframework {{{

augroup ft_xpframework
  au!
  autocmd BufRead,BufNewFile *.class.php setlocal fileencoding=latin1
  " Override expandtab vor xp:Changelog files
  autocmd FileType changelog setlocal expandtab
augroup END

" }}}

" }}}
" Spelling mistakes / abbreviations for Insert mode ----------------------- {{{

iab examlpe example
iab persond_id person_id
iab perosn_id person_id
iab vdvars var_dump(xdebug_get_declared_vars());
iab vdstack var_dump(xdebug_get_function_stack());
iab skpid 21240455
cab dbiall let dbext_default_DBI_max_rows=0
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
iab cdate <c-r>=strftime("%y-%m-%d")<cr>
iab @@p @param
iab @@r @return

" }}}
" Special commands -------------------------------------------------------- {{{

command! Ointernmail :o scp://internmail/~/httpd/
map <F8> :!gksudo "gvim -u /home/$USER/.vimrc /etc/apache2/sites-enabled/"<CR>
map <F9> :!gksudo /etc/init.d/apache2 restart<CR>

" }}}
" GUI --------------------------------------------------------------------- {{{

" get rid of menu
set guioptions-=m
:let g:toggleMenu = 0
map <silent> <S-F1> :if g:toggleMenu == 1<CR>:set guioptions-=m<CR>:set lines+=1<CR>:let g:toggleMenu = 0<CR>:else<CR>:set guioptions+=m<CR>:let g:toggleMenu = 1<CR>:endif<CR>

" get rid of toolbar
set guioptions-=T
:let g:toggleTool = 0
map <silent> <S-F2> :if g:toggleTool == 1<CR>:set guioptions-=T<CR>:set lines+=3<CR>:let g:toggleTool = 0<CR>:else<CR>:set lines-=3<CR>:set guioptions+=T<CR>:let g:toggleTool = 1<CR>:endif<CR>

" get rid of scrollbar
set guioptions-=r
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R

" win32  {{{

if has("win32")
    if has("gui_running")
        " alt jumps to menu
        set winaltkeys=menu
        " clipboard to autoselect
        set guioptions+=a

        " ---- Windows Like keys ----
        " CTRL-Z is Undo; not in cmdline though
        noremap <C-Z> u
        inoremap <C-Z> <C-O>u
        " CTRL-Y is Redo (although not repeat); not in cmdline though
        "noremap <C-Y> <C-R>
        "inoremap <C-Y> <C-O><C-R>
        " CTRL-A is Select all
        "noremap <C-A> gggH<C-O>G
        "inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
        "cnoremap <C-A> <C-C>gggH<C-O>G
        " CTRL-F4 is Close window
        noremap <C-F4> <C-W>c
        inoremap <C-F4> <C-O><C-W>c
        cnoremap <C-F4> <C-C><C-W>c
        " CTRL-Tab is Next window
        noremap <C-Tab> <C-W>w
        inoremap <C-Tab> <C-O><C-W>w
        cnoremap <C-Tab> <C-C><C-W>w
        " ---- Windows Like Copy-Paste keys ----
        " CTRL-v is paste
        "inoremap <C-v> <esc>"*p<return>i
        "noremap <C-v> "*p<return>
        " CTRL-x is cut (in visual mode only)
        "vnoremap <C-x> "*d
        " CTRL-c is copy (in visual mode only)
        "vnoremap <C-c> "*y
        " ---- Restore some remapped things 
        " make real <C-V> (visual block) as <C-Q> available
        noremap <c-q> <c-v>
        inoremap <C-Y> <C-Y>

    endif
endif

" }}}
"
" }}}
" Shell ------------------------------------------------------------------- {{{

if has("unix")
  set clipboard=autoselect
  set shell=/bin/bash
endif

if has("win32")
  set shell=C:\Windows\system32\cmd.exe
endif

function! s:ExecuteInShell(command) " {{{
    let command = join(map(split(a:command), 'expand(v:val)'))
    let winnr = bufwinnr('^' . command . '$')
    silent! execute  winnr < 0 ? 'botright vnew ' . fnameescape(command) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap nonumber
    echo 'Execute ' . command . '...'
    silent! execute 'silent %!'. command
    silent! redraw
    silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>:AnsiEsc<CR>'
    silent! execute 'nnoremap <silent> <buffer> q :q<CR>'
    silent! execute 'AnsiEsc'
    echo 'Shell command ' . command . ' executed.'
endfunction " }}}
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)
nnoremap <leader>! :Shell 

" }}}
" Vim grep ---------------------------------------------------------------- {{{

let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
set grepprg=grep\ -nH

" }}}
" Quickfix ---------------------------------------------------------------- {{{

" Close Quickfix window (,qq)
map <leader>qq :cclose<CR>

" QuickFix {{{

augroup ft_quickfix
    au!
    au Filetype qf setlocal colorcolumn=0 nolist nocursorline nowrap
augroup END

" }}}

" }}}
" Quick editing ----------------------------------------------------------- {{{

nnoremap <leader>ev :e $MYVIMRC<cr>
nnoremap <leader>ef :e ~/.vimperatorrc<cr>
nnoremap <leader>es :e ~/.vim/UltiSnips/<cr>
nnoremap <leader>ed :e ~/dotfiles/<cr>
nnoremap <leader>ec :e ~/.css<cr>
nnoremap <leader>ej :e ~/.js<cr>
nnoremap <leader>eq :e http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.js<cr>

" }}}
" vimrc helper ------------------------------------------------------------ {{{

" Synstack {{{

" Show the stack of syntax hilighting classes affecting whatever is under the
" cursor.
function! SynStack() "{{{
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), " > ")
endfunc "}}}

nnoremap <leader>ss :call SynStack()<CR>

" }}}

" }}}
" Learn it Bitch!!! :) ---------------------------------------------------- {{{

imap jj <esc>

inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
"noremap   <Up>     <NOP>
"noremap   <Down>   <NOP>
"noremap   <Left>   <NOP>
"noremap   <Right>  <NOP>

" }}}

