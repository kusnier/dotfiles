# $Id: bashrc 1441 2011-07-31 10:41:31Z seek $
case "$TERM" in
    xterm*|rxvt*)
      echo -e '\033[01;33m$Id: bashrc 1441 2011-07-31 10:41:31Z seek $'
      let "rcolor=($RANDOM % 6)+31"
      echo -e "\033[01;${rcolor}m"
      cat $HOME/dotfiles/bash/motd
    ;;
esac
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
export HISTCONTROL=ignoredups
# ... and ignore same sucessive entries.
export HISTCONTROL=ignoreboth
# typing a space in front of the command to ignore the command
export HISTCONTROL=ignorespace

# history, ignore
#export HISTIGNORE="pwd:ls:ls *:"
export HISTIGNORE="pwd:ls:"

# very long history file
export HISTSIZE=5000000
export HISTFILESIZE=5000000

# timestamp in history
export HISTTIMEFORMAT='%F %T '

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
shopt -s cdspell
shopt -s histappend

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
    ;;
*)
    ;;
esac

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

#if [ -f ~/.bash_aliases ]; then
#    . ~/.bash_aliases
#fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
fi

set -o vi

if [ "$HOSTNAME" = "matrixcode" ]; then
  export LC_TIME="de_DE.UTF-8"
fi

# Load ~/.bash_prompt, ~/.exports, ~/.aliases, ~/.functions and ~/.extra
# ~/.extra can be used for settings you don't want to commit
for file in paths bash_prompt exports aliases complete functions extra; do
file="$HOME/dotfiles/bash/$file"
  [ -e "$file" ] && source "$file"
done

# Disabled hostifle usage
#export HOSTFILE=~/dotfiles/bash/hostfile

# multiple tails on multiple machines
# url: http://stackoverflow.com/questions/106668/simultaneously-monitoring-multiple-log-files-over-ssh-on-windows
# usage:
#   [dsm@localhost:~]$ create-follower test1 user1 localhost /tmp/log-1.txt
#   [dsm@localhost:~]$ create-follower test2 user2 otherhost /tmp/log-2.txt
#   [dsm@localhost:~]$ create-follower test2 user3 remotebox /tmp/log-3.txt
#
#   [dsm@localhost:~]$ activate-followers test1 test2 test3
#
#   [dsm@localhost:~]$ stop-followers
function create-follower () {
    local _NAME=$1;
    local _USER=$2;
    local _HOST=$3;
    local _PATH=$4;

    if ! [ "${_NAME}" ]\
    || ! [ "${_USER}" ]\
    || ! [ "${_HOST}" ]\
    || ! [ "${_PATH}" ] ; then
        {   echo "Cannot create log follower." ;
            echo;
            echo "Usage: create-follower NAME USER HOST LOG-FILE";
        } >&2;
        return 1 ;
    fi ;

    eval "function ${_NAME}(){ ssh ${_USER}@${_HOST} tail -f \"${_PATH}\" & }"
}

function activate-followers () {
    if (( $# < 1 )) ; then
        {   echo "You must specify at least one follower to use" ;
            echo ;
            echo "Usage:" ;
            echo "    activate-followers follower1 [follower2 ... followerN]";
        } >&2;
        return 1 ;
    fi ;

    for FOLLOW in "${@}" ; do
        ${FOLLOW} ;
    done ;

    wait;
}

function stop-followers () {
    if [ "$(jobs)" ] ; then
        kill -9 $(jobs | perl -pe 's/\[([0-9]+)\].*/%$1/') ;
    fi ;
}
